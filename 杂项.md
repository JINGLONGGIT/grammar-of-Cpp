# 杂项

<!-- TOC -->

- [杂项](#杂项)
  - [柔性数组](#柔性数组)
    - [代码示例](#代码示例)
  - [`offsetof`](#offsetof)
    - [作用](#作用)
    - [返回值](#返回值)
    - [头文件](#头文件)
    - [代码示例一](#代码示例一)
    - [代码示例二](#代码示例二)
  - [静态断言 `static_assert`](#静态断言-static_assert)
    - [语法](#语法)
    - [含义](#含义)
    - [性能](#性能)
    - [和 `assert` / `#error` 的区别](#和-assert--error-的区别)
    - [参考链接](#参考链接)
  - [`typename` 关键字](#typename-关键字)

<!-- /TOC -->

## 柔性数组
### 代码示例

```cpp
struct ListNode
{
    ListNode* prev;
    ListNode* next;
    char data[];
};
```

对于柔性数组来说，数组名并不占用空间，它只是一个偏移量，代表一个不可修改的地址常量

## `offsetof` 
### 作用
计算结构体成员相对于结构体开头的偏移量

### 返回值
返回一个 `size_t` 类型的常量

### 头文件
C标准库 `<stddef.h>`，C++标准库 `<cstddef>`

### 代码示例一
```cpp
#include <stddef.h>
#include <stdio.h>

struct address {
   char name[50];
   char street[50];
   int phone;
};
   
int main()
{
   printf("address 结构中的 name 偏移 = %d 字节。\n",
   offsetof(struct address, name));
   
   printf("address 结构中的 street 偏移 = %d 字节。\n",
   offsetof(struct address, street));
   
   printf("address 结构中的 phone 偏移 = %d 字节。\n",
   offsetof(struct address, phone));

   return(0);
} 
```

让我们编译并运行上面的程序，这将产生以下结果：

```cpp
address 结构中的 name 偏移 = 0 字节。
address 结构中的 street 偏移 = 50 字节。
address 结构中的 phone 偏移 = 100 字节。
```

### 代码示例二
```cpp
struct ListNode
{
    ListNode* prev;
    ListNode* next;
    char data[];
};

offsetof(ListNode, data);       // 结构体成员data相对于结构体开头的偏移量 =8
```

```cpp
ListNode* node = (ListNode*)(data - offsetof(ListNode, data));
// data的地址减去data相对于结构体开头的偏移量，即可以得到结构体的地址
```

## 静态断言 `static_assert`
### 语法
```cpp
static_assert(常量表达式，提示字符串);
```

### 含义
如果第一个参数常量表达式的值为真(true或者非零值)，那么 `static_assert` 不做任何事；否则会产生一条编译错误信息

### 性能
由于 `static_assert` 属于编译期间断言，不生成目标代码，因此 `static_assert` 不会造成任何运行期间的性能损失

### 和 `assert` / `#error` 的区别
`assert` 是运行期断言，它用来发现运行期间的错误，不能提前到编译期发现错误，也不具有强制性，也谈不上改善编译信息的可读性，既然是运行期检查，对性能当然是有影响的，所以经常在发行版本中，`assert` 都会被关掉  

`#error` 可看做预编译期断言，甚至都算不上断言，仅仅能在预编译时显示一个错误信息，它能做的不多，可以参与预编译的条件检查，由于它无法获得编译信息，当然就做不了更进一步分析了

### 参考链接
[C++11 静态断言(static_assert)](https://www.cnblogs.com/lvdongjie/p/4489835.html)


## `typename` 关键字
`ArrayList` 模块源码中有多处使用了 `typename` 关键字。比如

```cpp
using InterLockGuard = typename std::conditional<is_thread_safe, LockGuard, EmptyLockGuard>::type;
```

在这里，`typename` 关键字的含义是指出后面的 `std::conditional<is_thread_safe, LockGuard, EmptyLockGuard>::type` 是类型名而不是变量

```cpp
// 同样的，使用 `typename` 指出 `return_type` 和 `type` 都是类型名而不是变量
static_assert(std::is_same<typename traits::return_tye, bool>::value && traits::args_count == 1 && std::is_same<typename traits::template argument<0>::type, const T>::value, "handler must be a bool(const T&) functor");
```