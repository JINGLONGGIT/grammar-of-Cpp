# 杂项

<!-- TOC -->

- [杂项](#杂项)
- [前向声明](#前向声明)
  - [避免头文件循环引用](#避免头文件循环引用)
  - [避免引入头文件](#避免引入头文件)
- [C++11：runtime_error](#c11runtime_error)
- [C++11 强枚举类型 enum class](#c11-强枚举类型-enum-class)
  - [传统枚举类型](#传统枚举类型)
  - [传统枚举类型的缺点](#传统枚举类型的缺点)
  - [强枚举类型](#强枚举类型)
  - [强枚举类型的优点](#强枚举类型的优点)

<!-- /TOC -->


# 前向声明
C++的类可以进行前向声明
* 前向声明类只能用于**定义指针、引用以及用于函数形参的指针和引用或者函数的返回类型**  
* 不能定义对象，因为此时编译器还不知道类的大小。也不能用于访问类的对象

## 避免头文件循环引用
假设有两个类A和B，类A需要将类B的对象或者指针作为自己的成员使用；此时类B也需要将类A的对象或者指针作为自己的成员使用。那么这时候我们就需要在类A的头文件 `<a.h>` 中包含类B的头文件 `<b.h>` ，也需要在类B的头文件 `<b.h>` 中包含类A的头文件 `<a.h>` 。但是这种相互包含是不允许的。  

我们可以使用前向声明来解决这种问题：

```cpp
// a.h
class B;

class A 
{
public:
    A(){};

private:
    B* b_; 
};
```

```cpp
// b.h
class A;

class B
{
public:
    B(){};

private:
    A* a_;    
};

```

## 避免引入头文件
如果类A用到了某个内部的类，打包时就不得不把内部的头文件也对外开放。库的开发者肯定不希望对外暴露内部的细节，所以需要利用前向声明跳过

# C++11：runtime_error 
`std::runtime_error`：错误运行异常类。只有在运行时才能够检测到的错误，继承于 `std::exception`，它的声明在头文件 `<stdexcept>` 中  

`std::runtime_error` 没有默认的构造函数，但是有两个声明为 `explicit` 的构造函数，分别接收参数为 `const char*` 和 `const std::string&` 。这些实参负责提供错误的更多信息  

`std::runtime_error` 也用作几个运行时错误异常的基类。包括 `std::range_error` (生成的结果超出了有意义的值域范围)、`overflow_error` (上溢)、`underflow_error` (下溢)、`system_error` (系统错误)  

# C++11 强枚举类型 enum class
## 传统枚举类型

```cpp
// 定义一个描述性别的枚举类型
enum Gender
{
    Male,
    Female
};
```

## 传统枚举类型的缺点
* 同作用域同名枚举值会报重定义错误。传统C++中枚举常量被暴露在同一层作用域中，如果同一作用域下有两个不同的枚举类型，但含有同名的枚举常量也是会报编译错误的。比如

```cpp
enum Fruits
{
    Apple,
    Tomato,
    Orange
};

enum Vegetables
{
    Cucumber,
    Tomato,
    Pepper
};

//编译报Tomato重定义错误
```

其中 `Fruits` 和 `Vegetables` 两个枚举类型中包含同名的 `Tomato` 枚举常量会导致编译错误。因为  `enum` 是非强作用域类型，枚举常量可以直接访问，这种访问方式与C++中具名的 `namespace`、`class/struct` 以及 `union` 必须通过 `名字::成员名` 的访问方式大相径庭

* 由于枚举类型被设计为常量数值的“别名”，所以枚举常量总是可以被隐式转换为整型，且用户无法为枚举常量定义类型

* 枚举常量占用存储空间以及符号性不确定。C++标准规定C++枚举所基于的“基础类型”是由编译器来具体实现，这会导致枚举类型成员的基本类型存在不确定性问题，尤其是符号性问题

```cpp
enum A{A1=1,A2=2,ABig=0xFFFFFFFFU};
enum B{B1=1,B2=2,BBig=0xFFFFFFFFFUL};

int main()
{
	cout<<sizeof(A1)<<endl;	//4
	cout<<ABig<<endl;		//4294967295
	cout<<sizeof(B1)<<endl;	//8
	cout<<BBig<<endl;		//68719476735
}
```

以上输出结果是在Linux平台下使用g++编译输出的结果，VC++(VS2017)中的输出结果分别是4、-1、4和-1。可见不同编译器对枚举常量的整型类型的宽度和符号有着不同的实现。GNU C++会根据枚举数值的类型使用不同宽度和符号的整型，VC++则始终以有符号int来表示枚举常量   

为了解决以上传统枚举类型的缺陷，C++11引入了强类型枚举解决了这些问题

## 强枚举类型
强类型枚举使用 `enum class` 语法来声明

```cpp
enum class Enumeration
{
    VAL1,
    VAL2,
    VAL3 = 100,
    VAL4
};
```

## 强枚举类型的优点
* 强作用域，强类型枚举成员的名称不会被输出到其父作用域，所以不同枚举类型定义同名枚举成员编译不会报重定义错误。进而使用枚举类型的枚举成员时，必须指明所属范围，比如 `Enumeration::VAL1`，而单独的 `VAL1` 则不再具有意义
* 转换限制，强类型枚举成员的值不可以与整型发生隐式相互转换。比如 `Enumeration::VAL4 == 10` 会触发编译错误；
* 可以指定底层类型。强类型枚举默认的底层类型是 `int`，但也可以显示地指定底层类型。具体方法是在枚举名称后面加上 `:type`，其中 `type` 可以是除 `wchar_t` 以外的任何整型。比如：

```cpp
enum class Type:char
{
    Low,
    Middle,
    High
};
```

注意：
* 声明强类型枚举的时候，既可以使用关键字 `enum class`，也可以使用 `enum struct`。事实上，`enum struct` 与 `enum class` 在语法上没有任何区别
